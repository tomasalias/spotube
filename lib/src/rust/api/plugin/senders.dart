// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'models/album.dart';
import 'models/artist.dart';
import 'models/audio_source.dart';
import 'models/browse.dart';
import 'models/core.dart';
import 'models/image.dart';
import 'models/pagination.dart';
import 'models/playlist.dart';
import 'models/search.dart';
import 'models/track.dart';
import 'models/user.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'plugin.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`

class PluginAlbumSender {
  const PluginAlbumSender();

  Future<SpotubeFullAlbumObject> getAlbum(
          {required OpaqueSender mpscTx, required String id}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAlbumSenderGetAlbum(
          that: this, mpscTx: mpscTx, id: id);

  Future<SpotubePaginationResponseObject> releases(
          {required OpaqueSender mpscTx, int? offset, int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAlbumSenderReleases(
          that: this, mpscTx: mpscTx, offset: offset, limit: limit);

  Future<void> save(
          {required OpaqueSender mpscTx, required List<String> ids}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAlbumSenderSave(
          that: this, mpscTx: mpscTx, ids: ids);

  Future<SpotubePaginationResponseObject> tracks(
          {required OpaqueSender mpscTx,
          required String id,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAlbumSenderTracks(
          that: this, mpscTx: mpscTx, id: id, offset: offset, limit: limit);

  Future<void> unsave(
          {required OpaqueSender mpscTx, required List<String> ids}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAlbumSenderUnsave(
          that: this, mpscTx: mpscTx, ids: ids);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginAlbumSender && runtimeType == other.runtimeType;
}

class PluginArtistSender {
  const PluginArtistSender();

  Future<SpotubePaginationResponseObject> albums(
          {required OpaqueSender mpscTx,
          required String id,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginArtistSenderAlbums(
          that: this, mpscTx: mpscTx, id: id, offset: offset, limit: limit);

  Future<SpotubeFullArtistObject> getArtist(
          {required OpaqueSender mpscTx, required String id}) =>
      RustLib.instance.api.crateApiPluginSendersPluginArtistSenderGetArtist(
          that: this, mpscTx: mpscTx, id: id);

  Future<SpotubePaginationResponseObject> related(
          {required OpaqueSender mpscTx,
          required String id,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginArtistSenderRelated(
          that: this, mpscTx: mpscTx, id: id, offset: offset, limit: limit);

  Future<void> save(
          {required OpaqueSender mpscTx, required List<String> ids}) =>
      RustLib.instance.api.crateApiPluginSendersPluginArtistSenderSave(
          that: this, mpscTx: mpscTx, ids: ids);

  Future<SpotubePaginationResponseObject> topTracks(
          {required OpaqueSender mpscTx,
          required String id,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginArtistSenderTopTracks(
          that: this, mpscTx: mpscTx, id: id, offset: offset, limit: limit);

  Future<void> unsave(
          {required OpaqueSender mpscTx, required List<String> ids}) =>
      RustLib.instance.api.crateApiPluginSendersPluginArtistSenderUnsave(
          that: this, mpscTx: mpscTx, ids: ids);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginArtistSender && runtimeType == other.runtimeType;
}

class PluginAudioSourceSender {
  const PluginAudioSourceSender();

  Future<List<SpotubeAudioSourceMatchObject>> matches(
          {required OpaqueSender mpscTx,
          required SpotubeFullTrackObject track}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAudioSourceSenderMatches(
          that: this, mpscTx: mpscTx, track: track);

  Future<List<SpotubeAudioSourceStreamObject>> streams(
          {required OpaqueSender mpscTx,
          required SpotubeAudioSourceMatchObject matched}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAudioSourceSenderStreams(
          that: this, mpscTx: mpscTx, matched: matched);

  Future<List<SpotubeAudioSourceContainerPreset>> supportedPresets(
          {required OpaqueSender mpscTx}) =>
      RustLib.instance.api
          .crateApiPluginSendersPluginAudioSourceSenderSupportedPresets(
              that: this, mpscTx: mpscTx);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginAudioSourceSender && runtimeType == other.runtimeType;
}

class PluginAuthSender {
  const PluginAuthSender();

  Future<void> authenticate({required OpaqueSender mpscTx}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAuthSenderAuthenticate(
          that: this, mpscTx: mpscTx);

  Future<bool> isAuthenticated({required OpaqueSender mpscTx}) =>
      RustLib.instance.api.crateApiPluginSendersPluginAuthSenderIsAuthenticated(
          that: this, mpscTx: mpscTx);

  Future<void> logout({required OpaqueSender mpscTx}) => RustLib.instance.api
      .crateApiPluginSendersPluginAuthSenderLogout(that: this, mpscTx: mpscTx);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginAuthSender && runtimeType == other.runtimeType;
}

class PluginBrowseSender {
  const PluginBrowseSender();

  Future<SpotubePaginationResponseObject> sectionItems(
          {required OpaqueSender mpscTx,
          required String id,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginBrowseSenderSectionItems(
          that: this, mpscTx: mpscTx, id: id, offset: offset, limit: limit);

  Future<SpotubePaginationResponseObject> sections(
          {required OpaqueSender mpscTx, int? offset, int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginBrowseSenderSections(
          that: this, mpscTx: mpscTx, offset: offset, limit: limit);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginBrowseSender && runtimeType == other.runtimeType;
}

class PluginCoreSender {
  const PluginCoreSender();

  Future<PluginUpdateAvailable?> checkUpdate(
          {required OpaqueSender mpscTx,
          required PluginConfiguration pluginConfig}) =>
      RustLib.instance.api.crateApiPluginSendersPluginCoreSenderCheckUpdate(
          that: this, mpscTx: mpscTx, pluginConfig: pluginConfig);

  Future<void> scrobble(
          {required OpaqueSender mpscTx, required ScrobbleDetails details}) =>
      RustLib.instance.api.crateApiPluginSendersPluginCoreSenderScrobble(
          that: this, mpscTx: mpscTx, details: details);

  Future<String> support({required OpaqueSender mpscTx}) => RustLib.instance.api
      .crateApiPluginSendersPluginCoreSenderSupport(that: this, mpscTx: mpscTx);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginCoreSender && runtimeType == other.runtimeType;
}

class PluginPlaylistSender {
  const PluginPlaylistSender();

  Future<void> addTracks(
          {required OpaqueSender mpscTx,
          required String playlistId,
          required List<String> trackIds,
          int? position}) =>
      RustLib.instance.api.crateApiPluginSendersPluginPlaylistSenderAddTracks(
          that: this,
          mpscTx: mpscTx,
          playlistId: playlistId,
          trackIds: trackIds,
          position: position);

  Future<SpotubeFullPlaylistObject?> createPlaylist(
          {required OpaqueSender mpscTx,
          required String userId,
          required String name,
          String? description,
          bool? public,
          bool? collaborative}) =>
      RustLib.instance.api
          .crateApiPluginSendersPluginPlaylistSenderCreatePlaylist(
              that: this,
              mpscTx: mpscTx,
              userId: userId,
              name: name,
              description: description,
              public: public,
              collaborative: collaborative);

  Future<void> deletePlaylist(
          {required OpaqueSender mpscTx, required String playlistId}) =>
      RustLib.instance.api
          .crateApiPluginSendersPluginPlaylistSenderDeletePlaylist(
              that: this, mpscTx: mpscTx, playlistId: playlistId);

  Future<SpotubeFullPlaylistObject> getPlaylist(
          {required OpaqueSender mpscTx, required String id}) =>
      RustLib.instance.api.crateApiPluginSendersPluginPlaylistSenderGetPlaylist(
          that: this, mpscTx: mpscTx, id: id);

  Future<void> removeTracks(
          {required OpaqueSender mpscTx,
          required String playlistId,
          required List<String> trackIds}) =>
      RustLib.instance.api
          .crateApiPluginSendersPluginPlaylistSenderRemoveTracks(
              that: this,
              mpscTx: mpscTx,
              playlistId: playlistId,
              trackIds: trackIds);

  Future<void> save(
          {required OpaqueSender mpscTx, required String playlistId}) =>
      RustLib.instance.api.crateApiPluginSendersPluginPlaylistSenderSave(
          that: this, mpscTx: mpscTx, playlistId: playlistId);

  Future<SpotubePaginationResponseObject> tracks(
          {required OpaqueSender mpscTx,
          required String id,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginPlaylistSenderTracks(
          that: this, mpscTx: mpscTx, id: id, offset: offset, limit: limit);

  Future<void> unsave(
          {required OpaqueSender mpscTx, required String playlistId}) =>
      RustLib.instance.api.crateApiPluginSendersPluginPlaylistSenderUnsave(
          that: this, mpscTx: mpscTx, playlistId: playlistId);

  Future<void> updatePlaylist(
          {required OpaqueSender mpscTx,
          required String playlistId,
          String? name,
          String? description,
          bool? public,
          bool? collaborative}) =>
      RustLib.instance.api
          .crateApiPluginSendersPluginPlaylistSenderUpdatePlaylist(
              that: this,
              mpscTx: mpscTx,
              playlistId: playlistId,
              name: name,
              description: description,
              public: public,
              collaborative: collaborative);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginPlaylistSender && runtimeType == other.runtimeType;
}

class PluginSearchSender {
  const PluginSearchSender();

  Future<SpotubePaginationResponseObject> albums(
          {required OpaqueSender mpscTx,
          required String query,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginSearchSenderAlbums(
          that: this,
          mpscTx: mpscTx,
          query: query,
          offset: offset,
          limit: limit);

  Future<SpotubeSearchResponseObject> all(
          {required OpaqueSender mpscTx, required String query}) =>
      RustLib.instance.api.crateApiPluginSendersPluginSearchSenderAll(
          that: this, mpscTx: mpscTx, query: query);

  Future<SpotubePaginationResponseObject> artists(
          {required OpaqueSender mpscTx,
          required String query,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginSearchSenderArtists(
          that: this,
          mpscTx: mpscTx,
          query: query,
          offset: offset,
          limit: limit);

  Future<List<String>> chips({required OpaqueSender mpscTx}) => RustLib
      .instance.api
      .crateApiPluginSendersPluginSearchSenderChips(that: this, mpscTx: mpscTx);

  Future<SpotubePaginationResponseObject> playlists(
          {required OpaqueSender mpscTx,
          required String query,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginSearchSenderPlaylists(
          that: this,
          mpscTx: mpscTx,
          query: query,
          offset: offset,
          limit: limit);

  Future<SpotubePaginationResponseObject> tracks(
          {required OpaqueSender mpscTx,
          required String query,
          int? offset,
          int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginSearchSenderTracks(
          that: this,
          mpscTx: mpscTx,
          query: query,
          offset: offset,
          limit: limit);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginSearchSender && runtimeType == other.runtimeType;
}

class PluginTrackSender {
  const PluginTrackSender();

  Future<SpotubeFullTrackObject> getTrack(
          {required OpaqueSender mpscTx, required String id}) =>
      RustLib.instance.api.crateApiPluginSendersPluginTrackSenderGetTrack(
          that: this, mpscTx: mpscTx, id: id);

  Future<List<SpotubeFullTrackObject>> radio(
          {required OpaqueSender mpscTx, required String id}) =>
      RustLib.instance.api.crateApiPluginSendersPluginTrackSenderRadio(
          that: this, mpscTx: mpscTx, id: id);

  Future<void> save(
          {required OpaqueSender mpscTx, required List<String> ids}) =>
      RustLib.instance.api.crateApiPluginSendersPluginTrackSenderSave(
          that: this, mpscTx: mpscTx, ids: ids);

  Future<void> unsave(
          {required OpaqueSender mpscTx, required List<String> ids}) =>
      RustLib.instance.api.crateApiPluginSendersPluginTrackSenderUnsave(
          that: this, mpscTx: mpscTx, ids: ids);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginTrackSender && runtimeType == other.runtimeType;
}

class PluginUserSender {
  const PluginUserSender();

  Future<SpotubeUserObject> me({required OpaqueSender mpscTx}) =>
      RustLib.instance.api
          .crateApiPluginSendersPluginUserSenderMe(that: this, mpscTx: mpscTx);

  Future<SpotubePaginationResponseObject> savedAlbums(
          {required OpaqueSender mpscTx, int? offset, int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginUserSenderSavedAlbums(
          that: this, mpscTx: mpscTx, offset: offset, limit: limit);

  Future<SpotubePaginationResponseObject> savedArtists(
          {required OpaqueSender mpscTx, int? offset, int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginUserSenderSavedArtists(
          that: this, mpscTx: mpscTx, offset: offset, limit: limit);

  Future<SpotubePaginationResponseObject> savedPlaylists(
          {required OpaqueSender mpscTx, int? offset, int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginUserSenderSavedPlaylists(
          that: this, mpscTx: mpscTx, offset: offset, limit: limit);

  Future<SpotubePaginationResponseObject> savedTracks(
          {required OpaqueSender mpscTx, int? offset, int? limit}) =>
      RustLib.instance.api.crateApiPluginSendersPluginUserSenderSavedTracks(
          that: this, mpscTx: mpscTx, offset: offset, limit: limit);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginUserSender && runtimeType == other.runtimeType;
}
